package io.github.baifangkual.jlib.vfs;

/**
 * <b>虚拟文件实体属性</b>
 *
 * @author baifangkual
 * @implNote 该类型出现的原因：在构建Local类型的VFS时，若Local类型为win端，
 * 则被表示为“虚拟文件实体”的“盘符”不应该做任何操作，但其也不应描述为“root”，
 * 遂，应有另一维度描述抽象该“盘符”的行为，再加之，原VFS实现中，VFile随提供IO流，
 * 但倘若其不可读写等（比如无权限），则应当在调用获取IO流之前，就需要以某种方式进行可控的描述，
 * 还有，VFile无法表达其描述的实际文件实体是否为”隐藏文件“等...
 * <p>另外，该类型的出现，也可以作为VFS的一个扩展点，而且原有的通过 {@link VFileType} 类型的
 * 描述当前实体是否为文件夹的行为也可被该类型囊括，遂后续若该类型应用，则移除 {@link VFileType} 类型。
 * 另，符号链接也可被该类型囊括，后续可支持该...
 * <p>该类型是一种多维度的描述
 * @since 2025/6/10 v0.1.2
 */
@Deprecated // 未完成
public enum VFileAttr {

    /*
    todo：
      20250618：已明确，文件和文件夹可使用 read write 形容性质
      其中，文件 read 表示字节可读 write表示字节可写（以这个角度来说，vfs目前还没有write的文件。。。
      文件夹的 read 表示其内部实体可见，write表示其内部实体可删除或创建
      但这样的话，每次删除某实体便需查看其父文件夹是否有write权限，繁琐，遂应当在 V_FILE 创建
      时就根据父文件夹是否有write给每个直接子实体（包括子文件夹）给定额外attr如 Deletable 标识其可删除与否，
      这样每次删除都不需要查看父文件夹是否有write权限了（这样有一个问题，即该Deletable标识仅能表示创建VFile时的可删除与否，
      若父文件夹变更了write权限，则此时标记便无法描述实际情况了；目前不考虑该问题：vfs认为实体权限不可变
      ----
      这样也解决了local win 情况下 虚拟的 root / 下 盘符的删除与否问题
      即 win下 / 仅有 read权限 /c 有read write权限但没有delete权限...
     */


    /*
    如何描述 readOnly？不应在这里描述，其readable表示其可读，而readonly在读写二分类描述中，
    可以表达readable取反的结果，但在该类型表达的多个维度的情景下，readonly似乎声明了只有readable属性而没有其他，
    这是不正确的。
    另外，把simpleFile 和 dir描述在这里好吗？？？
    如果当前实体为文件夹，其readable属性表达什么？可以查看文件夹内部？
    如果当前实体为文件，rw属性好理解，可以读写字节
    但若为符号链接，其readable属性表达什么？？？若为文件夹呢？？？
    尤其文件夹的writeable属性？表达文件夹可向其中塞文件？
    那用mutable描述呢？？？
    而且，对于包含关系的attr，需要在此声明吗？？？
    fuck 乱
     */
    
    /*
    // ===== 基础类型 (必须且只能有一个) =====
    DIRECTORY(1 << 0),     // 目录
    REGULAR_FILE(1 << 1),  // 普通文件
    SYMBOLIC_LINK(1 << 2), // 符号链接 * 先暂时不支持
    SPECIAL_FILE(1 << 3),  // 特殊文件(设备文件等) * 先暂时不支持
    
    // ===== 访问权限 =====
    READABLE(1 << 4),     // 可读
    WRITABLE(1 << 5),     // 可写
    EXECUTABLE(1 << 6),   // 可执行 * 不应有该
    
    // ===== 文件特性 =====
    HIDDEN(1 << 7),       // 隐藏文件
    SYSTEM(1 << 8),       // 系统文件 * 不应有该
    ARCHIVE(1 << 9),      // 存档文件 * 不应有该
    TEMPORARY(1 << 10),  // 临时文件 * 可以判断是否在fs tmp 下即可？
    
    
    // ===== 特殊标志 =====
    MOUNT_POINT(1 << 13); // 挂载点(如Windows盘符)
    VFS_ROOT
     */

    vfsRoot(1L << 63),
    @Deprecated // 废弃
    sys_mount(1L << 62), // 这个能描述 win的盘符，但是！！！ 太多余！！！
    // 文件的读写是获取IO流，文件夹的读是能否看到文件夹内文件实体，文件夹的写是能否向其中增删文件实体，符号链接暂不考虑
    // 文件夹的读写还需细想，以这个角度来说，文件夹读写并非读表示读写当中的文件实体：
    // 一个位置，原本没没有文件，当向这个位置写入字节时，文件被创建了，并且占用越来越大，
    // 当这个位置删除时（以某种角度看待。这个文件中的字节减少直到0，到达0后，文件被删除了），
    // 当一个位置原本没有文件夹，当向其写入时，文件夹被创建，其中添加直接子文件，
    // 当这个位置删除时，以看向普通文件般相同的行为来说，其内部直接子级越来越少，直到自己了没了？？？
    // 草，理不清。。。。。。。。。。。。。。。
    readable(1L),
    writeable(1L << 1),
    directory(1L << 2),
    simpleFile(1L << 3),
    hidden(1L << 4),
    @Deprecated // 暂不考虑
    link(1L << 5),
    ;

    private final long bFlag;

    VFileAttr(long bFlag) {
        this.bFlag = bFlag;
    }


}
